### 20221129
- c 不支持函数重构，但是可以通过编译器实现简单的伪重构写法，本质上还是告诉编译器生成函数指针
- %s ,s1 : s1是char *类型的！！
- %c ,s2 : s2 是char 类型
- strcmp (s1,s2) : 按字符逐个进行比较，简单看成s1-s2，结果有负数，0， 正数！
### 20221124
- 数组指针
  - 右左大法, 先看右边再看左边，括号优先,[]优先级> *
    - 如果出现[] 则表示数组，数组内的数字表示元素个数
    - 左边出现* 表示元素是 指针
    - int p[10]和int *p[10]虽然p都是表示数组,但是由于第一个p也是第一个元素下标所以长度是4，相反第二个长度是8（32位系统4，64位系统8）
###20221119
- 变量初始化不为0
- auto 局部变量
- static 局部静态变量
	- static 不能和extern 共作用在同个变量，尤其是声明的时候
- register 不常用，不能引用内存地址，相当局限
- h文件尽量只写define 和 函数生命，不要用extern，因为extern是两个c文件自己规定使用的，比如A文件生命全局变量value1 ，那么B 文件只要生命extern int value1即可。
  - struct 类型定义也可以写在h文件
  - extern 也可以引用其他c文件的函数
- #include "malloc.h" 
	- malloc(sizeof(structName))
- struct 用法
	- struct book{}tech; # 相当于声明一个类型book,和一个变量tech
	- typedef struct book{} A,*B; # 相当于声明一个类型book,变量类型A 和 数组B
		- ``不同的是用法 , struct book; A a; B = malloc(sizeof(B))!!!``
    - struct 的长度是按照最长的那个数据类型进行整齐划分的
- 除法
  - 求余数和求商 都是整数，且求余数的两个输入都不能是小数
- 字符串
  - strlen 含有\0的 长度，所以是长度+1
  - sizeof 不含有\0 ，长度是正常的逻辑长度
  - printf("\618 \n"); // 八进制的 /618=18(十进制) 八进制没有8最多到7，所以解析为\61 +8=18
  - printf("\x43 \n"); // x表示16进制,表示66，即B
  - putchar('f'-'a'+'A' ); // putchar ,输入字符
  - printf("adfasdf\0DDDD \n"); //终止符\0 导致终止输出
  - scanf 的时候会自动进行匹配格式，最好先进行格式化否则输出不确定
    - ``float 对应 %f, double 对应 %lf，如果用double类型的地址获取数值会失败!! 反之亦然 ``
    - scanf("%2d%*1d%2d",&x4,&x5); %*1d 表示跳过1位数字
  - 输出%5d表示最少需要5位数字，不够的话则向右对其，左边补\u
  - 012 是八进制 = 10（十进制）不是12
    - %o 八进制输出
  - %8.4s 表示最少8位字符，且只保留其中前4位，向右对齐，左边补u
  - 补0 操作 %04d
  - 左对齐  -%4d
- 数字
  - 科学计数法 后面不能跟小数点，但是前面可以加小数 如 2.5E2 
- 逻辑
  - 如果布尔运算中是或运算，左边若为真，则右边会被忽略计算，直接跳过
  - int (*p)[n] : 一维数组的首个元素的指针 p+1 相当于元素跳到下一个int 元素
    - int *p[n] : 步长为数组[n]的指针 p+1 相当于 跳到下个数组(元素int)
    - int (*t)[N][N]: 二维数组的指针，相当于t 
- 函数
  - feof 如果已经读到结尾则 非0，否则则为0
